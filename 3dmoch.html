<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <title>PlaygroundX | Connected World</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <style>

        body { margin: 0; overflow: hidden; background: #fff; font-family: 'Inter', sans-serif; user-select: none; -webkit-user-select: none; }

        


        #reticle {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #reticle::before, #reticle::after {
            content: ''; position: absolute; background: rgba(0, 0, 0, 0.8);
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        #reticle::before { width: 2px; height: 100%; } /* Vertical Line */
        #reticle::after { width: 100%; height: 2px; } /* Horizontal Line */



        /* CHAT */

        #chat-container {

            position: absolute; bottom: 20px; left: 20px; width: 350px; height: 250px;

            pointer-events: auto; display: flex; flex-direction: column; gap: 10px;

        }

        #chat-feed {

            flex: 1; overflow-y: auto; display: flex; flex-direction: column; 

            justify-content: flex-end; text-shadow: 0 1px 2px rgba(255,255,255,0.8);

        }

        .chat-msg {

            background: rgba(255,255,255,0.9); color: #000; padding: 6px 12px; 

            border-radius: 8px; margin-top: 5px; font-size: 14px; width: fit-content;

            box-shadow: 0 2px 5px rgba(0,0,0,0.1); border: 1px solid #ccc; font-weight: 600;

        }

        #chat-input {

            background: rgba(255,255,255,0.95); border: 1px solid #999; color: #000;

            padding: 10px; border-radius: 20px; outline: none; box-shadow: 0 4px 10px rgba(0,0,0,0.1);

        }

        

        /* NAMETAGS */

        .nametag {

            position: absolute; color: #333; font-weight: bold; font-size: 12px;

            padding: 2px 6px; background: rgba(255,255,255,0.8); border: 1px solid #ccc;

            border-radius: 4px; transform: translate(-50%, -100%); pointer-events: none;

        }

        .chat-bubble-3d {

            position: absolute; background: #222; color: white; padding: 8px 12px;

            border-radius: 15px; font-size: 14px; font-weight: bold;

            transform: translate(-50%, -150%); max-width: 200px; text-align: center;

            pointer-events: none; opacity: 0; transition: opacity 0.3s;

        }

        .chat-bubble-3d::after {

            content: ''; position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%);

            border-width: 6px 6px 0; border-style: solid; border-color: #222 transparent transparent transparent;

        }



        /* UI ELEMENTS */

        #blocker {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            background: #ffffff; display: flex; flex-direction: column;

            align-items: center; justify-content: center; color: #333; pointer-events: auto; z-index: 999;

        }

        #btn-enter {

            padding: 15px 40px; background: #000; color: white; font-weight: bold;

            border: none; border-radius: 30px; font-size: 18px; cursor: pointer; margin-top: 20px;

            box-shadow: 0 10px 30px rgba(0,0,0,0.2);

        }



        #mini-profile {

            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);

            width: 300px; background: #fff; border: 1px solid #eee; border-radius: 20px;

            padding: 20px; color: #333; text-align: center; pointer-events: auto; z-index: 1000;

            box-shadow: 0 20px 50px rgba(0,0,0,0.2);

        }

        #mini-profile img { width: 80px; height: 80px; border-radius: 50%; border: 3px solid #8B5CF6; margin-bottom: 10px; object-fit: cover;}

        .close-btn { position: absolute; top: 15px; right: 15px; background: none; border: none; color: #999; font-size: 20px; cursor: pointer;}

        

        /* JOYSTICKS */

        .joystick-zone {

            position: absolute; bottom: 40px; width: 140px; height: 140px;

            pointer-events: auto; display: none; 

            border: 2px solid rgba(0,0,0,0.05); border-radius: 50%;

            background: rgba(0,0,0,0.03); backdrop-filter: blur(2px);

        }

        #stick-left { left: 30px; }

        #stick-right { right: 30px; }

        

        .knob {

            width: 60px; height: 60px; background: #333;

            border-radius: 50%; position: absolute; top: 40px; left: 40px;

            box-shadow: 0 5px 15px rgba(0,0,0,0.2); pointer-events: none; transition: transform 0.1s;

        }

        .knob.active { transition: none; background: #8B5CF6; transform: scale(1.1); }



        .gear-btn {

            position: absolute; top: -15px; right: -15px; width: 44px; height: 44px;

            background: #fff; border-radius: 50%; border: 1px solid #eee;

            display: flex; justify-content: center; align-items: center; cursor: pointer;

            box-shadow: 0 4px 10px rgba(0,0,0,0.1); font-size: 20px; pointer-events: auto; color: #333;

        }



        #settings-popup {

            display: none; position: absolute; bottom: 200px; left: 50%; transform: translateX(-50%);

            background: white; padding: 25px; border-radius: 20px; width: 280px;

            box-shadow: 0 20px 60px rgba(0,0,0,0.2); pointer-events: auto; text-align: center;

            border: 1px solid #f0f0f0;

        }

        .slider-group { margin-bottom: 20px; text-align: left; }

        .slider-label { font-size: 12px; font-weight: bold; color: #888; letter-spacing: 1px; margin-bottom: 8px; display: block; }

        input[type=range] { width: 100%; accent-color: #8B5CF6; height: 6px; border-radius: 3px; }



        @media (hover: none) and (pointer: coarse) {

             #btn-jump { display: flex; }
            

            .joystick-zone { display: block; }



            #btn-build, #btn-break { display: flex; }
            

            

            #chat-container { width: 100%; bottom: auto; top: 10px; left: 0; padding: 0 20px; height: 100px; pointer-events: none;}

            #chat-input { pointer-events: auto; background: rgba(255,255,255,0.95); }

            #chat-feed { mask-image: linear-gradient(to bottom, transparent, black 20%); }

        }






        #btn-jump {
            position: absolute; bottom: 200px; right: 60px; width: 80px; height: 80px;
            background: rgba(0,0,0,0.2); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%;
            color: white; font-weight: bold; display: flex; align-items: center; justify-content: center;
            pointer-events: auto; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); z-index: 1001;
            user-select: none; -webkit-touch-callout: none;
        }
        #btn-jump:active { background: rgba(255,255,255,0.2); transform: scale(0.95); }





        /* Mobile Build Buttons */
        .action-btn {
            position: absolute; width: 60px; height: 60px; border-radius: 50%;
            color: white; font-weight: bold; font-size: 24px; display: flex;
            align-items: center; justify-content: center; backdrop-filter: blur(4px);
            border: 2px solid rgba(255,255,255,0.3); z-index: 1001;
            user-select: none; -webkit-touch-callout: none;
        }
        #btn-build { bottom: 210px; right: 150px; background: rgba(0, 200, 0, 0.3); }
        #btn-break { bottom: 290px; right: 60px; background: rgba(200, 0, 0, 0.3); }
        .action-btn:active { transform: scale(0.90); opacity: 0.8; }





        

        
    </style>

</head>

<body>



    <div id="ui-layer">

        <div id="reticle"></div>

        <div id="nametag-container"></div>

        

        <div id="chat-container">

            <div id="chat-feed"></div>

            <input type="text" id="chat-input" placeholder="Chat...">

        </div>



        <div id="settings-popup">

            <h3 style="margin:0 0 20px 0; color:#000;">Controls</h3>

            <div class="slider-group">

                <label class="slider-label">WALK SPEED</label>

                <input type="range" id="range-speed" min="2" max="20" step="1">

            </div>

            <div class="slider-group">

                <label class="slider-label">LOOK SENSITIVITY</label>

                <input type="range" id="range-sens" min="0.5" max="5" step="0.5">

            </div>



            <div class="slider-group">
                <label class="slider-label">CAMERA DISTANCE</label>
                <input type="range" id="range-dist" min="1" max="8" step="0.5">
            </div>
        

            <div class="slider-group">
                <label class="slider-label">CAMERA HEIGHT</label>
                <input type="range" id="range-height" min="0.5" max="5" step="0.2">
            </div>

            <div class="slider-group">
                <label class="slider-label">JUMP HEIGHT (Blocks)</label>
                <input type="range" id="range-jump" min="1" max="3" step="1" value="2">
            </div>

            <div class="slider-group" style="display: flex; align-items: center; justify-content: space-between;">
                <label class="slider-label" style="margin:0;">FLY MODE</label>
                <input type="checkbox" id="fly-mode-toggle" style="width: 20px; height: 20px;">
            </div>

            <div class="slider-group" style="display: flex; align-items: center; justify-content: space-between;">
                <label class="slider-label" style="margin:0;">AUTO JUMP</label>
                <input type="checkbox" id="auto-jump-toggle" style="width: 20px; height: 20px;">
            </div>


            <div class="slider-group" style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px;">





<div class="slider-group" style="display: flex; align-items: center; justify-content: space-between;">
    <label class="slider-label" style="margin:0;">PC MODE</label>
    <input type="checkbox" id="pc-mode-toggle" style="width: 20px; height: 20px;">
</div>

            
            

            <button id="close-settings" style="background:#000; color:white; border:none; padding:12px 30px; border-radius:30px; font-weight:bold; cursor:pointer;">DONE</button>

        </div>



        <div id="blocker">

            <h1 style="font-size: 40px; margin: 0; letter-spacing: -1px;">Playground<span style="color:#8B5CF6">X</span></h1>

            <p style="color:#888; font-weight: 500;">White Void Lounge</p>

            <div id="loading-txt" style="margin-top:20px; color:#aaa;">Initializing...</div>

            <button id="btn-enter" style="display:none;">ENTER WORLD</button>

            <button id="btn-offline" style="margin-top:10px; background:#666; color:white; border:none; padding:10px 20px; border-radius:20px; font-weight:bold; cursor:pointer; display:none;">PLAY OFFLINE</button>
    


            <button onclick="window.location.href='index.html'" style="margin-top:20px; background:transparent; border:none; color:#888; font-weight:bold; cursor: pointer;">Exit</button>

        </div>



        <div id="stick-left" class="joystick-zone">

            <div class="knob"></div>

        </div>

        <div id="stick-right" class="joystick-zone">

            <div class="knob"></div>

            <div class="gear-btn" id="btn-settings">⚙</div>

        </div>

                <div id="btn-jump">JUMP</div>




         <div id="btn-build" class="action-btn">+</div>
        <div id="btn-break" class="action-btn">-</div>
        
        
    </div>



    <div id="mini-profile">

        <button class="close-btn" onclick="document.getElementById('mini-profile').style.display='none'">✕</button>

        <img id="mp-img" src="">

        <h2 id="mp-name">Name</h2>

        <p id="mp-bio" style="color:#aaa; font-size: 14px;">...</p>

        <button style="background: #8B5CF6; color: white; border: none; width: 100%; padding: 12px; border-radius: 10px; font-weight:bold; margin-top: 10px; cursor: pointer;">Add Friend</button>

    </div>



    <script type="importmap">

        {

            "imports": {

                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",

                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"

            }

        }

    </script>



    <script >

        import * as THREE from 'three';

        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";

        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        import { getFirestore, collection, doc, getDoc, setDoc, onSnapshot, serverTimestamp, updateDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";



        // --- 1. FIREBASE ---

        const firebaseConfig = {

            apiKey: "AIzaSyDFmhk3ybnsVsFenCE3xvdmy5y_4u9ss7o", 

            authDomain: "playgroundx-ca021.firebaseapp.com",

            projectId: "playgroundx-ca021",

            storageBucket: "playgroundx-ca021.firebasestorage.app",

            messagingSenderId: "427340828971",

            appId: "1:427340828971:web:1d9e2dc22ecd69593eb56e",

            measurementId: "G-NEV8FYG0WK"

        };



        const app = initializeApp(firebaseConfig);

        const auth = getAuth(app);

        const db = getFirestore(app);

        const APP_ID = "playgroundX_Prod_v1";



        let myUid = localStorage.getItem('pgX_myUid');

        let myData = {

            alias: localStorage.getItem('pgX_alias') || "Visitor",

            img: localStorage.getItem('my_profile_pic') || "https://via.placeholder.com/150",

            x: 0, y: 0, z: 12, rot: 0

        };

        const players = {}; 

        const chatTimeouts = {};

        

        const config = { 
            moveSpeed: 10.0, 
            lookSpeed: 2.0,
            jumpPower: 24.0, // Default to 2 blocks
            flyMode: false,
            autoJump: false
        };
        

        // --- FLYING CONTROL VARIABLES ---
        let jumpHeld = false;
        let isFlyingDown = false;
        let lastJumpRelease = 0;

        // Jump Math: v = sqrt(2 * g * height)
        // Gravity = 147. 
        // 1 Block (1.0m) -> 17.1
        // 2 Blocks (2.0m) -> 24.2
        // 3 Blocks (3.0m) -> 29.7
        const jumpValues = { "1": 17.5, "2": 24.5, "3": 30.0 };
        


                // FORCE MOBILE BY DEFAULT
        let isMobile = true; 
        // --- MISSING INPUT VARIABLE ---
        const input = {
         move: { x: 0, y: 0 },
         look: { x: 0, y: 0 }
         };
        
        
                // --- GLOBAL CAMERA VARIABLES ---
        let eyeLevel = 1.6;
        let cameraFollowDist = 3.0; 
        



        // --- NEW FEATURES VARIABLES ---
        let isOffline = false;
        const velocity = new THREE.Vector3();
        let canJump = false;
        
        // Block Building Setup
        const voxelGeo = new THREE.BoxGeometry(1, 1, 1);
        const voxelMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        
        const voxels = []; // Keep track of placed blocks




        

        // --- SETTINGS UI ---

        document.getElementById('btn-settings').addEventListener('pointerdown', (e) => {

            e.stopPropagation();

            document.getElementById('settings-popup').style.display = 'block';

            document.getElementById('range-speed').value = config.moveSpeed;

            document.getElementById('range-sens').value = config.lookSpeed;

        });

        document.getElementById('close-settings').addEventListener('click', () => {

             document.getElementById('settings-popup').style.display = 'none';

        });

        document.getElementById('range-speed').addEventListener('input', (e) => config.moveSpeed = parseFloat(e.target.value));

                document.getElementById('range-sens').addEventListener('input', (e) => config.lookSpeed = parseFloat(e.target.value));

        // --- NEW SETTINGS LISTENERS ---
        document.getElementById('range-jump').addEventListener('input', (e) => {
            config.jumpPower = jumpValues[e.target.value];
        });
        document.getElementById('fly-mode-toggle').addEventListener('change', (e) => {
            config.flyMode = e.target.checked;
            velocity.y = 0; // Reset velocity when toggling
        });
        document.getElementById('auto-jump-toggle').addEventListener('change', (e) => {
            config.autoJump = e.target.checked;
        });

                // --- CAMERA SETTINGS ---
        

                // --- CAMERA SETTINGS ---
        // Set initial slider positions
        document.getElementById('range-dist').value = cameraFollowDist;
        document.getElementById('range-height').value = eyeLevel;

        // Listen for changes
        document.getElementById('range-dist').addEventListener('input', (e) => cameraFollowDist = parseFloat(e.target.value));
        document.getElementById('range-height').addEventListener('input', (e) => eyeLevel = parseFloat(e.target.value));
        



        // --- PC MODE TOGGLE LOGIC ---
        const pcToggle = document.getElementById('pc-mode-toggle');
        
        // 1. Set initial state (Unchecked because we are Mobile First)
        pcToggle.checked = false;

        // 2. Listen for changes
        pcToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                // SWITCH TO PC MODE
                isMobile = false;
                document.querySelectorAll('.joystick-zone, #btn-jump, .action-btn').forEach(el => el.style.display = 'none');
                alert("PC Mode Active: Click screen to lock mouse.");
            } else {
                // SWITCH TO MOBILE MODE
                isMobile = true;
                document.querySelectorAll('.joystick-zone, #btn-jump, .action-btn').forEach(el => el.style.display = 'flex');
                document.exitPointerLock();
            }
        });
        


        

        // --- AUTH ---

        async function initConnection() {

            if (!myUid) {

                try { const cred = await signInAnonymously(auth); myUid = cred.user.uid; } catch(e){}

            }

            try {

                const docSnap = await getDoc(doc(db, 'artifacts', APP_ID, 'public', 'data', 'users', myUid));

                if (docSnap.exists()) {

                    const d = docSnap.data();

                    myData.alias = d.alias || myData.alias;

                    myData.img = d.img || myData.img;

                }

            } catch (e) { }



            document.getElementById('loading-txt').style.display = 'none';

            document.getElementById('btn-enter').style.display = 'block';




            document.getElementById('btn-offline').style.display = 'block';
            
            // Offline Button Logic
            document.getElementById('btn-offline').addEventListener('click', () => {
                isOffline = true;
                // Generate a random temporary ID for offline play
                myUid = "offline_" + Math.random().toString(36).substr(2, 9);
                if (isMobile) {
                    blocker.style.display = 'none';
                    document.querySelectorAll('.joystick-zone').forEach(el => el.style.display = 'flex');
                } else {
                    controls.lock();
                }
            });












            

            onSnapshot(collection(db, 'artifacts', APP_ID, 'public', 'data', 'world_players'), (snapshot) => {

                snapshot.docChanges().forEach((change) => {

                    const pid = change.doc.id;

                    const pdata = change.doc.data();

                    if (pid === myUid) return; 

                    if (change.type === "added") spawnPlayer(pid, pdata);

                    if (change.type === "modified") updatePlayer(pid, pdata);

                    if (change.type === "removed") removePlayer(pid);

                });

            });

        }

        initConnection();



        // --- THREE.JS SCENE ---

        const scene = new THREE.Scene();

        scene.background = new THREE.Color(0xffffff); 

        scene.fog = new THREE.Fog(0xffffff, 100, 500);



        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        camera.rotation.order = 'YXZ'; 

        

        
        

        camera.position.set(0, eyeLevel, 15); 

        camera.rotation.y = 0; 



        // RENDERER & SHADOWS

        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.toneMapping = THREE.ACESFilmicToneMapping;

        renderer.shadowMap.enabled = true; // Enabled Shadows

        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);



        // LIGHTS

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);

        scene.add(hemiLight);



        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);

        dirLight.position.set(10, 50, 20);

        dirLight.castShadow = true; 

        dirLight.shadow.mapSize.width = 2048;

        dirLight.shadow.mapSize.height = 2048;

        dirLight.shadow.camera.near = 0.5;

        dirLight.shadow.camera.far = 500;

        // Fix for "Peter Panning" (Shadow Detachment) - Reduced Bias

        dirLight.shadow.bias = -0.0005; 

        dirLight.shadow.camera.left = -100;

        dirLight.shadow.camera.right = 100;

        dirLight.shadow.camera.top = 100;

        dirLight.shadow.camera.bottom = -100;

        scene.add(dirLight);



        // --- PHYSICS & COLLIDERS ---

        const colliders = []; 



        // Exterior Floor

        const ground = new THREE.Mesh(new THREE.CircleGeometry(200, 64), new THREE.MeshStandardMaterial({ color: 0xffffff }));

        ground.rotation.x = -Math.PI / 2; 

        ground.position.y = -0.1;

        ground.receiveShadow = true;

        scene.add(ground);

        colliders.push(ground); 



        const gridHelper = new THREE.GridHelper(300, 300, 0xeeeeee, 0xf5f5f5);

        scene.add(gridHelper);



        // Glass Octagon

        const octGroup = new THREE.Group();

        const glassMat = new THREE.MeshPhysicalMaterial({

            color: 0xffffff, metalness: 0.1, roughness: 0.3, transmission: 0.9, thickness: 1.0, side: THREE.DoubleSide, transparent: true

        });

        const octRadius = 8; 

        const sideLen = 6.2;

        

        for (let i = 0; i < 8; i++) {

            if (i === 0) continue; 

            const angle = (i / 8) * Math.PI * 2;

            const wall = new THREE.Mesh(new THREE.BoxGeometry(sideLen, 6, 0.2), glassMat);

            wall.position.x = Math.cos(angle) * octRadius;

            wall.position.z = Math.sin(angle) * octRadius;

            wall.position.y = 3;

            wall.rotation.y = -angle + (Math.PI/2);

            octGroup.add(wall);

        }

        

        const frameMat = new THREE.MeshStandardMaterial({color: 0x111111});

        const dL = new THREE.Mesh(new THREE.BoxGeometry(1, 6, 0.5), frameMat); dL.position.set(-3, 3, octRadius); octGroup.add(dL);

        const dR = new THREE.Mesh(new THREE.BoxGeometry(1, 6, 0.5), frameMat); dR.position.set(3, 3, octRadius); octGroup.add(dR);

        const dT = new THREE.Mesh(new THREE.BoxGeometry(7, 1, 0.5), frameMat); dT.position.set(0, 5.5, octRadius); octGroup.add(dT);



        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 128;

        const ctx = canvas.getContext('2d');

        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,512,128);

        ctx.fillStyle = '#000'; ctx.font = 'bold 60px Arial'; ctx.textAlign = 'center'; ctx.fillText('Playground X', 256, 85);

        const logoMesh = new THREE.Mesh(new THREE.BoxGeometry(5, 1.2, 0.1), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(canvas)}));

        logoMesh.position.set(0, 6.2, octRadius + 0.1);

        octGroup.add(logoMesh);



        const roof = new THREE.Mesh(new THREE.ConeGeometry(octRadius + 1, 3, 8), glassMat);

        roof.position.y = 7.5; octGroup.add(roof);

        octGroup.position.z = -10; 

        scene.add(octGroup);



        const ghostHall = new THREE.Group();

        ghostHall.position.z = -10; 

        const gFloor = new THREE.Mesh(new THREE.PlaneGeometry(16, 16), new THREE.MeshBasicMaterial({color:0xffffff}));

        gFloor.rotation.x = -Math.PI/2;

        ghostHall.add(gFloor);

        scene.add(ghostHall);



        // --- INTERIOR (GRAND REVEAL) ---

        const bigRoomY = -200; 

        const bigRoom = new THREE.Group();

        bigRoom.position.y = bigRoomY;

        

        const bigFloor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0xffffff }));

        bigFloor.rotation.x = -Math.PI / 2; 

        bigFloor.position.y = 0.05;

        bigFloor.receiveShadow = true;

        bigRoom.add(bigFloor);

        

        const bigGrid = new THREE.GridHelper(200, 100, 0xeeeeee, 0xf5f5f5);

        bigGrid.position.y = 0.1;

        bigRoom.add(bigGrid);



        const floorCollider = bigFloor.clone();

        floorCollider.position.y = bigRoomY;

        floorCollider.visible = false;

        scene.add(floorCollider);

        colliders.push(floorCollider);



        const roomGeo = new THREE.BoxGeometry(200, 80, 200);

        const roomMat = new THREE.MeshStandardMaterial({ color: 0x888888, side: THREE.BackSide });

        const roomMesh = new THREE.Mesh(roomGeo, roomMat);

        roomMesh.position.y = 40;

        bigRoom.add(roomMesh);



        // FIX: PLATFORM SIZE REDUCED

        const balconyDepth = 15;

        const balconyGeo = new THREE.BoxGeometry(40, 2, balconyDepth);

        const balconyMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

        const balcony = new THREE.Mesh(balconyGeo, balconyMat);

        balcony.receiveShadow = true;

        balcony.position.set(0, 19, 100 - (balconyDepth/2)); 

        bigRoom.add(balcony);

        

        const balcCollider = balcony.clone();

        balcCollider.position.set(0, bigRoomY + 19, 100 - (balconyDepth/2));

        balcCollider.visible = false;

        scene.add(balcCollider);

        colliders.push(balcCollider);



        const exitFrame = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 1), new THREE.MeshStandardMaterial({color:0x111111}));

        exitFrame.position.set(0, 24, 99);

        bigRoom.add(exitFrame);



        // FIX: STAIRS DIRECTION & WIDTH

        const steps = 40;

        const stepWidth = 15;

        const stepGroup = new THREE.Group();

        stepGroup.position.set(0, 0, 100 - balconyDepth); 

        for(let i=0; i<steps; i++) {

            const step = new THREE.Mesh(new THREE.BoxGeometry(stepWidth, 0.5, 1.5), balconyMat);

            step.position.y = 20 - (i * 0.5);

            step.position.z = -(i * 1.5);

            step.castShadow = true; step.receiveShadow = true; 

            stepGroup.add(step);

        }

        bigRoom.add(stepGroup);



        const slopeGeo = new THREE.BoxGeometry(stepWidth + 2, 1, 62);

        const slope = new THREE.Mesh(slopeGeo, new THREE.MeshBasicMaterial({visible:false}));

        slope.position.set(0, bigRoomY + 10, 100 - balconyDepth - 31); 

        slope.rotation.x = -0.33; 

        scene.add(slope);

        colliders.push(slope);



        scene.add(bigRoom);



        // --- CONTROLS ---

        const controls = new PointerLockControls(camera, document.body);

        const blocker = document.getElementById('blocker');

        const btnEnter = document.getElementById('btn-enter');



        btnEnter.addEventListener('click', () => {

            if (isMobile) {

                blocker.style.display = 'none';

                document.querySelectorAll('.joystick-zone').forEach(el => el.style.display = 'flex');

            } else {

                controls.lock();

            }

        });



        controls.addEventListener('lock', () => blocker.style.display = 'none');

        controls.addEventListener('unlock', () => blocker.style.display = 'flex');



        function setupJoystick(id, inputKey) {

            const zone = document.getElementById(id);

            const knob = zone.querySelector('.knob');

            let rect, radius, center;

            let touchId = null;



            function updateMetrics() {

                rect = zone.getBoundingClientRect();

                radius = rect.width / 2;

                center = { x: rect.left + radius, y: rect.top + radius };

            }



            zone.addEventListener('touchstart', e => {

                if(e.target.classList.contains('gear-btn')) return;

                e.preventDefault();

                updateMetrics();

                touchId = e.changedTouches[0].identifier;

                handleMove(e.changedTouches[0]);

                knob.classList.add('active');

            }, {passive:false});



            zone.addEventListener('touchmove', e => {

                e.preventDefault();

                for(let i=0; i<e.changedTouches.length; i++) {

                    if(e.changedTouches[i].identifier === touchId) handleMove(e.changedTouches[i]);

                }

            }, {passive:false});



            const end = e => {

                e.preventDefault();

                touchId = null;

                input[inputKey].x = 0; input[inputKey].y = 0;

                knob.style.transform = `translate(0px, 0px)`;

                knob.classList.remove('active');

            };

            zone.addEventListener('touchend', end);



            function handleMove(touch) {

                let dx = touch.clientX - center.x;

                let dy = touch.clientY - center.y;

                const dist = Math.sqrt(dx*dx + dy*dy);

                const maxDist = radius - 30;

                if(dist > maxDist) { const r = maxDist/dist; dx*=r; dy*=r; }

                knob.style.transform = `translate(${dx}px, ${dy}px)`;

                input[inputKey].x = dx / maxDist;

                input[inputKey].y = dy / maxDist;

            }

        }

        if(isMobile) {

            setupJoystick('stick-left', 'move');

            setupJoystick('stick-right', 'look');

        }



        const keys = { w:0, a:0, s:0, d:0 };

        document.addEventListener('keydown', e => {

            if(e.code === 'KeyW') keys.w=1;

            if(e.code === 'KeyS') keys.s=1;

            if(e.code === 'KeyA') keys.a=1;

            if(e.code === 'KeyD') keys.d=1;

            if(e.code === 'Enter') document.getElementById('chat-input').focus();


            if (e.code === 'Space' && canJump) {
                velocity.y += 60.0;
                canJump = false;
            }


            

        });

        document.addEventListener('keyup', e => {

            if(e.code === 'KeyW') keys.w=0;

            if(e.code === 'KeyS') keys.s=0;

            if(e.code === 'KeyA') keys.a=0;

            if(e.code === 'KeyD') keys.d=0;

        });




        // --- MOBILE JUMP BUTTON ---
        // --- MOBILE JUMP BUTTON (UPDATED) ---
        const btnJump = document.getElementById('btn-jump');
        
        btnJump.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            jumpHeld = true;

            // FLYING LOGIC
            if (config.flyMode) {
                const now = Date.now();
                // Check for Double Tap (within 300ms)
                if (now - lastJumpRelease < 300) {
                    isFlyingDown = true; // Double tap hold = DOWN
                } else {
                    isFlyingDown = false; // Single press hold = UP
                }
            } 
            // NORMAL JUMP LOGIC
            else if (canJump) {
                velocity.y = config.jumpPower; 
                canJump = false;
            }
        }, { passive: false });

        btnJump.addEventListener('touchend', (e) => {
            e.preventDefault();
            jumpHeld = false;
            isFlyingDown = false;
            lastJumpRelease = Date.now(); // Record release time for double-tap check
        });
        








        

        function handleInteraction(isBuilding) {
            // Raycast from CENTER of screen (Crosshair)
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const allObjects = [...colliders, ...voxels];
            const intersects = raycaster.intersectObjects(allObjects);

            if (intersects.length > 0) {
                const hit = intersects[0];
                
                // BREAK BLOCK
                if (!isBuilding) {
                    if (voxels.includes(hit.object)) {
                        scene.remove(hit.object);
                        voxels.splice(voxels.indexOf(hit.object), 1);
                        const colIndex = colliders.indexOf(hit.object);
                        if (colIndex > -1) colliders.splice(colIndex, 1);
                    }
                }
                // BUILD BLOCK
                else {
                    const voxel = new THREE.Mesh(voxelGeo, voxelMat);
                    
                    // 1. Calculate the World Normal (Direction facing out)
                    const normal = hit.face.normal.clone();
                    normal.transformDirection(hit.object.matrixWorld).normalize();

                    // 2. Calculate Position (Add half normal to center in adjacent block)
                    const p = hit.point.clone().add(normal.multiplyScalar(0.5));

                    // 3. Snap to grid (Size 1.0)
                    voxel.position.x = Math.floor(p.x) + 0.5;
                    voxel.position.y = Math.floor(p.y) + 0.5;
                    voxel.position.z = Math.floor(p.z) + 0.5;

                    scene.add(voxel);
                    voxels.push(voxel);
                    colliders.push(voxel);
                }
            }
        }









        

        document.getElementById('btn-build').addEventListener('touchstart', (e) => {
             e.preventDefault(); 
             handleInteraction(true); // True = Build
        }, { passive: false });

        document.getElementById('btn-break').addEventListener('touchstart', (e) => {
             e.preventDefault(); 
             handleInteraction(false); // False = Break
        }, { passive: false });

        // PC Mouse Fallback (Optional, allows testing on PC too)
        document.addEventListener('mousedown', (e) => {
            if (controls.isLocked) {
                if (e.button === 0) handleInteraction(false); // Left Click = Break
                if (e.button === 2) handleInteraction(true);  // Right Click = Build
            }
        });



        const chatIn = document.getElementById('chat-input');

        chatIn.addEventListener('keydown', (e) => {

            if (e.key === 'Enter' && chatIn.value.trim() !== "") {

                sendChat(chatIn.value);

                chatIn.value = ""; chatIn.blur();

            }

        });



        // --- AVATAR SYSTEM (UPDATED) ---

        const texLoader = new THREE.TextureLoader();

        function createAvatar(imgUrl) {

            const group = new THREE.Group();

            const tex = texLoader.load(imgUrl);

            const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8 });

            const shirt = new THREE.MeshStandardMaterial({ color: 0x8B5CF6, roughness: 0.8 });

            const skin = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.8 });

            

            // FIX: Changed color to Dark Grey to prevent lighting artifacts (transparency look)

            const dark = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });



            // 1. Head (Named for animation)

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), mat);

            head.position.y = 1.5; 

            head.castShadow = true; 

            head.name = 'head'; 

            group.add(head);



            // 2. Body

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.25), shirt);

            body.position.y = 0.95; 

            body.castShadow = true; body.receiveShadow = true;

            group.add(body);









            // ... (keep head and body code above this) ...



            // 3. Limbs

            // FIX: Adjusted Pivot Points to close gaps

            // Arm/Leg Size: 0.15 width, 0.6 height

            const limbGeo = new THREE.BoxGeometry(0.15, 0.6, 0.15);

            // Shift geometry center down by half height (0.3) so pivot is at the very top

            limbGeo.translate(0, -0.3, 0); 

            

            // Body Width is 0.5 (Edge is 0.25). Arm Width is 0.15 (Half is 0.075).

            // 0.25 + 0.075 = 0.325 (Flush fit)

            

            const lArm = new THREE.Mesh(limbGeo, skin); 

            lArm.position.set(-0.325, 1.25, 0); // <-- DELETE OLD LINE, PASTE THIS (Brought X closer, Y higher)

            lArm.name="leftArm"; 

            lArm.castShadow=true;

            group.add(lArm);



            const rArm = new THREE.Mesh(limbGeo, skin); 

            rArm.position.set(0.325, 1.25, 0); // <-- DELETE OLD LINE, PASTE THIS (Brought X closer, Y higher)

            rArm.name="rightArm"; 

            rArm.castShadow=true;

            group.add(rArm);



            // Body Bottom is at 0.65 (0.95 center - 0.3 half height). 

            // Legs must spawn exactly at 0.65 Y.



            const lLeg = new THREE.Mesh(limbGeo, dark); 

            lLeg.position.set(-0.15, 0.65, 0); // <-- DELETE OLD LINE, PASTE THIS (Raised Y to close gap)

            lLeg.name="leftLeg"; 

            lLeg.castShadow=true;

            group.add(lLeg);



            const rLeg = new THREE.Mesh(limbGeo, dark); 

            rLeg.position.set(0.15, 0.65, 0); // <-- DELETE OLD LINE, PASTE THIS (Raised Y to close gap)

            rLeg.name="rightLeg"; 

            rLeg.castShadow=true;

            group.add(rLeg);



            return group;

        }





        

        

        

        

        



        function spawnPlayer(id, data) {

            const mesh = createAvatar(data.img);

            mesh.position.set(data.x, data.y, data.z);

            mesh.userData = data;

            scene.add(mesh);

            players[id] = { mesh: mesh, targetPos: new THREE.Vector3(data.x, data.y, data.z) };

            

            const ghost = createAvatar(data.img);

            ghost.traverse(c => { if(c.isMesh) { c.material = c.material.clone(); c.material.transparent=true; c.material.opacity=0.4; }});

            scene.add(ghost);

            players[id].ghost = ghost;



            const tag = document.createElement('div'); tag.className='nametag'; tag.innerText=data.alias; tag.id=`tag-${id}`;

            document.getElementById('nametag-container').appendChild(tag);

            const bub = document.createElement('div'); bub.className='chat-bubble-3d'; bub.id=`bub-${id}`;

            document.getElementById('nametag-container').appendChild(bub);

        }



        function updatePlayer(id, data) {

            if (players[id]) {

                players[id].targetPos.set(data.x, data.y, data.z);

                players[id].mesh.rotation.y = data.rot;

                

                // Head Sync

                const head = players[id].mesh.getObjectByName('head');

                if(head && data.headRotX !== undefined) {

                    head.rotation.x = data.headRotX;

                }



                if (data.chatMsg && data.chatTime > Date.now() - 5000) showBubble(id, data.chatMsg);

            }

        }



        function removePlayer(id) {

            if (players[id]) {

                scene.remove(players[id].mesh); scene.remove(players[id].ghost);

                document.getElementById(`tag-${id}`).remove(); document.getElementById(`bub-${id}`).remove();

                delete players[id];

            }

        }



        function showBubble(id, msg) {

            const el = document.getElementById(`bub-${id}`); el.innerText = msg; el.style.opacity = 1;

            if(chatTimeouts[id]) clearTimeout(chatTimeouts[id]);

            chatTimeouts[id] = setTimeout(() => el.style.opacity = 0, 5000);

            const feed = document.getElementById('chat-feed');

            const row = document.createElement('div'); row.className = 'chat-msg';

            const name = players[id] ? players[id].mesh.userData.alias : "Unknown";

            row.innerText = `${name}: ${msg}`; feed.appendChild(row); feed.scrollTop = feed.scrollHeight;

        }



        async function sendChat(txt) {

            if(!myUid) return;




            if (isOffline) {
                // If offline, just show message locally
                const feed = document.getElementById('chat-feed');
                const row = document.createElement('div'); row.className = 'chat-msg';
                row.innerText = `Me (Offline): ${txt}`; feed.appendChild(row); feed.scrollTop = feed.scrollHeight;
                return; 
            }

            

            await updateDoc(doc(db, 'artifacts', APP_ID, 'public', 'data', 'world_players', myUid), { chatMsg: txt, chatTime: Date.now() });

            const feed = document.getElementById('chat-feed');

            const row = document.createElement('div'); row.className = 'chat-msg';

            row.innerText = `Me: ${txt}`; feed.appendChild(row); feed.scrollTop = feed.scrollHeight;

        }



        // --- LOCAL AVATAR ---

        const myAvatar = createAvatar(myData.img);

        scene.add(myAvatar);



        // --- GRAVITY ENGINE & LOOP ---

        const clock = new THREE.Clock();

        const raycaster = new THREE.Raycaster();

        const downVec = new THREE.Vector3(0, -1, 0);

        let lastUpload = 0;



        // Optimized Upload Loop

        setInterval(async () => {

            if (!myUid) return;


            if (isOffline) return;
     

            const now = Date.now();

            if (now - lastUpload < 200) return; // Cap at 5 updates/sec

            lastUpload = now;



            try {

                // We send Camera Rotation X as 'headRotX' so others see us look up/down

                // Note: We invert it for the model

                await setDoc(doc(db, 'artifacts', APP_ID, 'public', 'data', 'world_players', myUid), {

                    x: myAvatar.position.x, 

                    y: myAvatar.position.y, 

                    z: myAvatar.position.z,

                    rot: myAvatar.rotation.y, // Body rotation

                    headRotX: -camera.rotation.x, // Head rotation

                    alias: myData.alias, img: myData.img,

                    lastSeen: serverTimestamp()

                }, { merge: true });

            } catch(e){}

        }, 200);





        // --- GRAVITY FUNCTION (CORRECTLY PLACED) ---
        // --- GRAVITY FUNCTION (CORRECTLY PLACED) ---
        function updateGravity(delta) {
            // FLY MODE LOGIC
            if (config.flyMode) {
                // 1. Decelerate (Drag) to stop quickly when button released
                velocity.y *= 0.8; 

                // 2. Apply Movement Force
                if (jumpHeld) {
                    if (isFlyingDown) {
                        velocity.y = -15.0; // Go Down
                    } else {
                        velocity.y = 15.0;  // Go Up
                    }
                }

                // 3. Apply Velocity
                camera.position.y += velocity.y * delta;
                return; // Skip standard gravity/collisions
            }

            // STANDARD PHYSICS
            // 1. Apply Gravity
            velocity.y -= 9.8 * 15.0 * delta; 
            
            // 2. Move Camera Y based on Velocity
            camera.position.y += velocity.y * delta;


            // 3. Check for Floor Collision
            const yaw = camera.rotation.y;
            const avX = camera.position.x - Math.sin(yaw) * cameraFollowDist;
            const avZ = camera.position.z - Math.cos(yaw) * cameraFollowDist;

            const feetPos = camera.position.y - eyeLevel;
            raycaster.set(new THREE.Vector3(avX, feetPos + 1, avZ), new THREE.Vector3(0, -1, 0));

            const intersects = raycaster.intersectObjects(colliders);
            
            // If we are close to the ground (within 1.5 units) AND falling
            if (intersects.length > 0 && intersects[0].distance < 1.5 && velocity.y <= 0) {
                velocity.y = 0;
                camera.position.y = intersects[0].point.y + eyeLevel;
                canJump = true;
            } else {
                 canJump = false;
            }

            // Floor Reset (Kill Zone)
            if (camera.position.y < -300) {
                velocity.y = 0;
                camera.position.set(0, 10, 0);
            }
        }







        // --- NEW HELPER: Check if moving will hit a wall ---
        function checkWallCollision(moveOffset) {
            // 1. Calculate where the Avatar IS right now
            const yaw = camera.rotation.y;
            const avX = camera.position.x - Math.sin(yaw) * cameraFollowDist;
            const avZ = camera.position.z - Math.cos(yaw) * cameraFollowDist;
            const startPos = new THREE.Vector3(avX, camera.position.y - eyeLevel + 1, avZ);

            // 2. Raycast in the direction of movement
            const dir = moveOffset.clone().normalize();
            // Length of move + buffer (0.5 for body size)
            const dist = moveOffset.length() + 0.5; 
            
            raycaster.set(startPos, dir);
            const intersects = raycaster.intersectObjects(colliders);
            
            // 3. Return TRUE if we hit something close
            return (intersects.length > 0 && intersects[0].distance < dist);
        }

        // --- NEW HELPER: Smart Camera (Visual Clip) ---
        function getSmartCameraPos() {
            // 1. Where is the Avatar's Head?
            const yaw = camera.rotation.y;
            const avX = camera.position.x - Math.sin(yaw) * cameraFollowDist;
            const avZ = camera.position.z - Math.cos(yaw) * cameraFollowDist;
            const headPos = new THREE.Vector3(avX, camera.position.y - eyeLevel + 1.5, avZ);

            // 2. Where does the Camera WANT to be?
            const idealPos = camera.position.clone();
            
            // 3. Check for walls between Head and Camera
            const dir = new THREE.Vector3().subVectors(idealPos, headPos).normalize();
            const dist = headPos.distanceTo(idealPos);
            
            raycaster.set(headPos, dir);
            const intersects = raycaster.intersectObjects(colliders);

            // 4. If wall found, return a closer point
            if (intersects.length > 0 && intersects[0].distance < dist) {
                return intersects[0].point.add(dir.multiplyScalar(-0.2)); // Move slightly in front of wall
            }
            return idealPos; // No wall, return original
        }





        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            const speed = config.moveSpeed * delta;
            
            // 1. CALCULATE INTENDED MOVEMENT
            let moveX = 0;
            let moveZ = 0;
            const yaw = camera.rotation.y;

            if (isMobile) {
                const sens = config.lookSpeed * delta;
                
                // Camera Rotation
                const oldYaw = camera.rotation.y;
                camera.rotation.y -= input.look.x * sens;
                const newYaw = camera.rotation.y;
                
                // Orbit Logic (Keep distance)
                if (input.look.x !== 0) {
                    camera.position.x += (Math.sin(newYaw) - Math.sin(oldYaw)) * cameraFollowDist;
                    camera.position.z += (Math.cos(newYaw) - Math.cos(oldYaw)) * cameraFollowDist;
                }

                // Look Up/Down
                camera.rotation.x -= input.look.y * sens;
                camera.rotation.x = Math.max(-0.6, Math.min(0.6, camera.rotation.x));
                
                // Calculate Walk Vector
                const fwd = -input.move.y; 
                const strafe = input.move.x;
                if(Math.abs(fwd) > 0.1 || Math.abs(strafe) > 0.1) {
                    moveX -= (Math.sin(yaw)*fwd - Math.cos(yaw)*strafe) * speed;
                    moveZ -= (Math.cos(yaw)*fwd + Math.sin(yaw)*strafe) * speed;
                }
            } else if (controls.isLocked) {
                // PC Movement
                const fwd = Number(keys.w) - Number(keys.s);
                const strafe = Number(keys.d) - Number(keys.a);
                if(fwd || strafe) {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    dir.y = 0; dir.normalize();
                    const side = new THREE.Vector3(-dir.z, 0, dir.x);
                    
                    const v = dir.multiplyScalar(fwd * speed).add(side.multiplyScalar(strafe * speed));
                    moveX = v.x;
                    moveZ = v.z;
                }
            }

            // 2. CHECK WALL COLLISION (The Fix)

            // 2. CHECK WALL COLLISION + AUTO JUMP
            const moveVec = new THREE.Vector3(moveX, 0, moveZ);
            const hitWall = checkWallCollision(moveVec);

            if (hitWall) {
                // If Auto-Jump is ON and we are on the ground, Jump!
                if (config.autoJump && canJump) {
                     velocity.y = config.jumpPower;
                     canJump = false;
                }
            } else {
                // Only move if safe
                camera.position.x += moveX;
                camera.position.z += moveZ;
            }

            
            // 3. GRAVITY
            updateGravity(delta);

            // 4. SYNC AVATAR TO PHYSICS POSITION
            const currentYaw = camera.rotation.y;
            myAvatar.position.x = camera.position.x - Math.sin(currentYaw) * cameraFollowDist;
            myAvatar.position.z = camera.position.z - Math.cos(currentYaw) * cameraFollowDist;
            myAvatar.position.y = camera.position.y - eyeLevel;
            myAvatar.rotation.y = currentYaw + Math.PI; 
            
            const myHead = myAvatar.getObjectByName('head');
            if(myHead) myHead.rotation.x = -camera.rotation.x; 

            // Limb Animations
            const isMoving = (Math.abs(moveX) > 0.001 || Math.abs(moveZ) > 0.001);
            if(isMoving) {
                const walkSpeed = 10;
                const limbAngle = Math.sin(time * walkSpeed) * 0.5;
                const lArm = myAvatar.getObjectByName('leftArm');
                const rArm = myAvatar.getObjectByName('rightArm');
                const lLeg = myAvatar.getObjectByName('leftLeg');
                const rLeg = myAvatar.getObjectByName('rightLeg');
                if(lArm) lArm.rotation.x = limbAngle;
                if(rArm) rArm.rotation.x = -limbAngle;
                if(lLeg) lLeg.rotation.x = -limbAngle;
                if(rLeg) rLeg.rotation.x = limbAngle;
            }

            // 5. RENDER PHASE (Smart Camera Clip)
            // Save actual position
            const physicsPos = camera.position.clone();
            
            // Move camera visually if blocked (The "Underneath" fix)
            const visualPos = getSmartCameraPos();
            camera.position.copy(visualPos);


               // --- FADE AVATAR IF CLOSE ---
               // 1. Calculate distance from Camera to Avatar's Head
               const headTarget = myAvatar.position.clone().add(new THREE.Vector3(0, 1.5, 0));
               const distToHead = camera.position.distanceTo(headTarget);
   
               // 2. Determine Opacity (0.1 if close, 1.0 if far)
                const targetOpacity = distToHead < 1.2 ? 0.1 : 1.0; 

                // 3. Apply to all parts of the avatar
                  myAvatar.traverse((child) => {
                   if(child.isMesh) {
                     // Enable transparency if not already set
                    if(!child.material.transparent) child.material.transparent = true; 
                    // Smoothly fade the opacity
                     child.material.opacity = THREE.MathUtils.lerp(child.material.opacity, targetOpacity, 0.2);
                  }
               });






            
            // Render
            // Sync other players
            for (const id in players) {
                const p = players[id];
                p.mesh.position.lerp(p.targetPos, 0.1);
                // ... (Keep existing player sync code) ...
            }
            renderer.render(scene, camera);

            // Restore actual position for next physics frame
            camera.position.copy(physicsPos);
        }
        




        
        animate();

        



        window.addEventListener('mousedown', () => { if(isMobile) return; checkIntersects(); });

        window.addEventListener('touchstart', (e) => {

            if(e.touches.length === 1 && !e.target.classList.contains('knob')) checkIntersects();

        });



        function checkIntersects() {

            raycaster.setFromCamera({x:0,y:0}, camera);

            const intersects = raycaster.intersectObjects(scene.children, true);

            for(let i=0; i<intersects.length; i++) {

                let obj = intersects[i].object;

                while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;

                if(obj.userData && obj.userData.alias) {

                    document.getElementById('mp-img').src = obj.userData.img;

                    document.getElementById('mp-name').innerText = obj.userData.alias;

                    document.getElementById('mini-profile').style.display = 'block';

                    if(!isMobile) controls.unlock();

                    return;

                }

        }

        }



        window.addEventListener('resize', () => {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

});

    </script>

</body>

</html>






























